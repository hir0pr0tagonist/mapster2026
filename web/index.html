<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mapster OSM + Boundaries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
        // Tooltip element
        const tooltip = document.createElement('div');
        tooltip.style.position = 'absolute';
        tooltip.style.background = 'rgba(255,255,255,0.95)';
        tooltip.style.border = '1px solid #888';
        tooltip.style.borderRadius = '4px';
        tooltip.style.padding = '4px 8px';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.display = 'none';
        tooltip.style.zIndex = '10';
        document.body.appendChild(tooltip);
      console.log("Mapster script loaded");
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          osm: {
            type: 'raster',
            tiles: [
              'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            tileSize: 256,
            attribution: 'Â© OpenStreetMap contributors'
          }
        },
        layers: [
          {
            id: 'osm',
            type: 'raster',
            source: 'osm',
            minzoom: 6,
            maxzoom: 11
          }
        ]
      },
      center: [13.4, 52.52], // Berlin
      zoom: 7,
      minZoom: 6,
      maxZoom: 11
    });

    // Vector tiles (MVT) served by the API.
    // These auto-load as you pan/zoom, and are generally much faster than shipping large GeoJSON blobs.

    function computeDepthFromProps(props) {
      // Depth is the count of populated name_1..name_5.
      // (name_0 is always the country name)
      let depth = 0;
      for (let i = 1; i <= 5; i++) {
        const v = props && props['name_' + i];
        if (typeof v === 'string' && v.trim() !== '') depth = i;
      }
      return depth;
    }

    map.on('load', () => {
      map.addSource('admin-tiles', {
        type: 'vector',
        tiles: ['http://localhost:8080/api/tiles/{z}/{x}/{y}.mvt'],
        minzoom: 0,
        maxzoom: 14
      });

      // Transparent fill for hit-testing.
      map.addLayer({
        id: 'boundaries-fill',
        type: 'fill',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'fill-color': '#000000',
          'fill-opacity': 0
        }
      });

      // Hover highlight fill UNDER the lines so boundaries remain visible.
      map.addLayer({
        id: 'boundaries-highlight',
        type: 'fill',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'fill-color': '#00aaff',
          'fill-opacity': 0.18
        },
        filter: ['==', ['get', 'id'], '']
      });

      // Outline always on top.
      map.addLayer({
        id: 'boundaries-line',
        type: 'line',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'line-color': '#ff0000',
          'line-width': 2
        }
      });

      // Single mousemove handler (no duplicates on refresh).
      map.on('mousemove', (e) => {
        const features = map.queryRenderedFeatures(e.point, { layers: ['boundaries-fill'] });
        if (!features || features.length === 0) {
          map.setFilter('boundaries-highlight', ['==', ['get', 'id'], '']);
          tooltip.style.display = 'none';
          return;
        }

        // Prefer the most detailed feature if multiple overlap.
        let best = features[0];
        let bestDepth = computeDepthFromProps(best.properties);
        for (const f of features) {
          const d = computeDepthFromProps(f.properties);
          if (d > bestDepth) {
            best = f;
            bestDepth = d;
          }
        }

        const bestId = best && best.properties ? best.properties.id : null;
        if (bestId == null) {
          map.setFilter('boundaries-highlight', ['==', ['get', 'id'], '']);
          tooltip.style.display = 'none';
          return;
        }

        map.setFilter('boundaries-highlight', ['==', ['get', 'id'], bestId]);

        const names = [];
        for (let i = 0; i <= 5; i++) {
          const key = 'name_' + i;
          const v = best.properties && best.properties[key];
          if (typeof v === 'string' && v.trim() !== '') names.push(v);
        }
        if (names.length === 0 && best.properties && best.properties.name) {
          names.push(best.properties.name);
        }

        tooltip.innerText = names.length > 0 ? names.join('\n') : 'Unknown';
        tooltip.style.display = 'block';
        tooltip.style.left = (e.originalEvent.clientX + 10) + 'px';
        tooltip.style.top = (e.originalEvent.clientY + 10) + 'px';
      });
    });
  </script>
</body>
</html>
