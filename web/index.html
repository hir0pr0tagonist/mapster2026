<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mapster OSM + Boundaries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100vw; height: 100vh; }
    #legend {
      position: absolute;
      right: 12px;
      top: 12px;
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid #aaa;
      border-radius: 6px;
      padding: 10px;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 11;
      max-width: 230px;
    }
    #legend .title { font-weight: 600; margin-bottom: 6px; }
    #legend .subtitle { color: #333; margin-bottom: 8px; }
    #legend .row { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    #legend .swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.2); }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="legend">
    <div class="title" style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
      <span id="legend-title">Metric bands</span>
      <select id="metric-select" style="max-width:160px;"></select>
    </div>
    <div class="subtitle" id="legend-subtitle">Relative to bbox average</div>
    <div class="row"><span class="swatch" style="background:#00441b"></span><span>&le; 0.50× avg (very cheap)</span></div>
    <div class="row"><span class="swatch" style="background:#006d2c"></span><span>&le; 0.75× avg</span></div>
    <div class="row"><span class="swatch" style="background:#31a354"></span><span>&le; 0.90× avg</span></div>
    <div class="row"><span class="swatch" style="background:#74c476"></span><span>&le; 0.97× avg</span></div>
    <div class="row"><span class="swatch" style="background:#c7e9c0"></span><span>&le; 1.00× avg</span></div>
    <hr style="border:none;border-top:1px solid rgba(0,0,0,0.12);margin:8px 0;" />
    <div class="row"><span class="swatch" style="background:#fee5d9"></span><span>&gt; 1.00× avg</span></div>
    <div class="row"><span class="swatch" style="background:#fcae91"></span><span>&ge; 1.10× avg</span></div>
    <div class="row"><span class="swatch" style="background:#fb6a4a"></span><span>&ge; 1.25× avg</span></div>
    <div class="row"><span class="swatch" style="background:#de2d26"></span><span>&ge; 1.50× avg</span></div>
    <div class="row"><span class="swatch" style="background:#a50f15"></span><span>&ge; 2.00× avg (very expensive)</span></div>
  </div>
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
        // Basic error logging to make debugging in DevTools easier.
        window.addEventListener('error', (e) => {
          console.error('Window error:', e && e.message, e);
        });
        window.addEventListener('unhandledrejection', (e) => {
          console.error('Unhandled promise rejection:', e && e.reason, e);
        });

        // Tooltip element
        const tooltip = document.createElement('div');
        tooltip.style.position = 'absolute';
        tooltip.style.background = 'rgba(255,255,255,0.95)';
        tooltip.style.border = '1px solid #888';
        tooltip.style.borderRadius = '4px';
        tooltip.style.padding = '4px 8px';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.display = 'none';
        tooltip.style.zIndex = '10';
        document.body.appendChild(tooltip);
      console.log("Mapster script loaded");
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          osm: {
            type: 'raster',
            tiles: [
              'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            tileSize: 256,
            attribution: '© OpenStreetMap contributors'
          }
        },
        layers: [
          {
            id: 'osm',
            type: 'raster',
            source: 'osm',
            minzoom: 6,
            maxzoom: 11
          }
        ]
      },
      center: [13.4, 52.52], // Berlin
      zoom: 7,
      minZoom: 6,
      maxZoom: 11
    });

    map.on('error', (e) => {
      // MapLibre provides useful tile/style/source errors here.
      console.error('MapLibre error:', e && (e.error || e));
    });

    // Vector tiles (MVT) served by the API.
    // These auto-load as you pan/zoom, and are generally much faster than shipping large GeoJSON blobs.

    function computeDepthFromProps(props) {
      // Depth is the count of populated name_1..name_5.
      // (name_0 is always the country name)
      let depth = 0;
      for (let i = 1; i <= 5; i++) {
        const v = props && props['name_' + i];
        if (typeof v === 'string' && v.trim() !== '') depth = i;
      }
      return depth;
    }

    function depthForZoom(zoom) {
      // Must match api ZoomDepthMapper: zoom <= 6 => 0, zoom >= 11 => 5, else z-6
      const z = Math.floor(Number(zoom));
      if (!Number.isFinite(z)) return 0;
      if (z <= 6) return 0;
      if (z >= 11) return 5;
      return z - 6;
    }

    map.on('load', () => {
      let currentMetricId = 'price_eur_per_m2_land';

      // Local dev note:
      // - In Ingress-style setups, the browser can reach the API at same-origin `/api/...`.
      // - In docker-compose, the UI is on :8081 and the API is on :8080.
      // We keep this deterministic (no CORS-dependent probing).
      const apiBase = (() => {
        const sameOriginBase = window.location.origin + '/api';
        const hostBase = window.location.protocol + '//' + window.location.hostname + ':8080/api';
        if (window.location.port === '8081') return hostBase;
        return sameOriginBase;
      })();
      console.log('Using API base:', apiBase);

      const metricSelect = document.getElementById('metric-select');
      const legendTitle = document.getElementById('legend-title');

      function setLegendTitle() {
        if (legendTitle) legendTitle.textContent = `Bands: ${currentMetricId}`;
      }
      setLegendTitle();

      map.addSource('admin-tiles', {
        type: 'vector',
        tiles: [apiBase + '/tiles/{z}/{x}/{y}.mvt'],
          // Required for feature-state: use a stable per-area identifier as the feature id.
          // area_key matches the metrics join key and stays stable across imports.
          promoteId: 'area_key',
        minzoom: 0,
        maxzoom: 14
      });

      const bandToColor = {
        1: '#00441b',
        2: '#006d2c',
        3: '#31a354',
        4: '#74c476',
        5: '#c7e9c0',
        6: '#fee5d9',
        7: '#fcae91',
        8: '#fb6a4a',
        9: '#de2d26',
        10: '#a50f15'
      };

      const bandColorExpression = [
        'match',
        ['feature-state', 'band'],
        1, bandToColor[1],
        2, bandToColor[2],
        3, bandToColor[3],
        4, bandToColor[4],
        5, bandToColor[5],
        6, bandToColor[6],
        7, bandToColor[7],
        8, bandToColor[8],
        9, bandToColor[9],
        10, bandToColor[10],
        'rgba(0,0,0,0)'
      ];

      // Transparent fill for hit-testing.
      map.addLayer({
        id: 'boundaries-fill',
        type: 'fill',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'fill-color': '#000000',
            // Keep it effectively invisible, but non-zero so hit-testing stays reliable.
            'fill-opacity': 0.001
        }
      });

      // Hover highlight fill UNDER the lines so boundaries remain visible.
      map.addLayer({
        id: 'boundaries-highlight',
        type: 'fill',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'fill-color': '#00aaff',
          'fill-opacity': [
            'case',
            ['boolean', ['feature-state', 'hover'], false],
            0.18,
            0
          ]
        }
      });

      // Outline always on top.
      map.addLayer({
        id: 'boundaries-line',
        type: 'line',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'line-color': '#ff0000',
          'line-width': 2
        }
      });

      // Metric shading (vector tiles) underneath the boundary lines.
      // We color by feature-state.band, which is populated from /area-metrics-values.
      map.addLayer({
        id: 'metrics-fill',
        type: 'fill',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'fill-color': bandColorExpression,
          'fill-opacity': 0.38
        }
      }, 'boundaries-highlight');

      // Hover highlight + tooltip.
      // Attach events to the topmost hit-test layer (`boundaries-fill`) so pointer events fire reliably.
      let hoveredFeatureId = null;

      map.on('mouseenter', 'boundaries-fill', () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'boundaries-fill', () => {
        map.getCanvas().style.cursor = '';
        if (hoveredFeatureId != null) {
          map.setFeatureState({ source: 'admin-tiles', sourceLayer: 'admin', id: hoveredFeatureId }, { hover: false });
          hoveredFeatureId = null;
        }
        tooltip.style.display = 'none';
      });

      map.on('mousemove', 'boundaries-fill', (e) => {
        const features = (e && e.features) ? e.features : [];
        if (!features || features.length === 0) {
          if (hoveredFeatureId != null) {
            map.setFeatureState({ source: 'admin-tiles', sourceLayer: 'admin', id: hoveredFeatureId }, { hover: false });
            hoveredFeatureId = null;
          }
          tooltip.style.display = 'none';
          return;
        }

        // Prefer the most detailed feature if multiple overlap.
        let best = features[0];
        let bestDepth = computeDepthFromProps(best.properties);
        for (const f of features) {
          const d = computeDepthFromProps(f.properties);
          if (d > bestDepth) {
            best = f;
            bestDepth = d;
          }
        }

        const bestFeatureId = (best && best.id != null) ? best.id : null;
        if (bestFeatureId == null) {
          tooltip.style.display = 'none';
          return;
        }

        if (hoveredFeatureId !== bestFeatureId) {
          if (hoveredFeatureId != null) {
            map.setFeatureState({ source: 'admin-tiles', sourceLayer: 'admin', id: hoveredFeatureId }, { hover: false });
          }
          hoveredFeatureId = bestFeatureId;
          map.setFeatureState({ source: 'admin-tiles', sourceLayer: 'admin', id: hoveredFeatureId }, { hover: true });
        }

        const names = [];
        for (let i = 0; i <= 5; i++) {
          const key = 'name_' + i;
          const v = best.properties && best.properties[key];
          if (typeof v === 'string' && v.trim() !== '') names.push(v);
        }
        if (names.length === 0 && best.properties && best.properties.name) {
          names.push(best.properties.name);
        }

        const metricLine = (() => {
          const st = map.getFeatureState({ source: 'admin-tiles', sourceLayer: 'admin', id: bestFeatureId }) || {};
          const avgNum = Number(st.avg);
          const band = st.band;
          if (!Number.isFinite(avgNum) || band == null) return null;
          if (!Number.isFinite(currentGlobalAvg) || currentGlobalAvg === 0) {
            return `avg: ${avgNum.toFixed(0)} (band ${band})`;
          }
          const ratioNum = avgNum / currentGlobalAvg;
          return `avg: ${avgNum.toFixed(0)} (bbox avg: ${currentGlobalAvg.toFixed(0)}, ${ratioNum.toFixed(2)}×, band ${band})`;
        })();

        tooltip.innerText = [
          ...(names.length > 0 ? [names.join('\n')] : ['Unknown']),
          ...(metricLine ? [metricLine] : [])
        ].join('\n');
        tooltip.style.display = 'block';
        tooltip.style.left = (e.originalEvent.clientX + 10) + 'px';
        tooltip.style.top = (e.originalEvent.clientY + 10) + 'px';
      });

      function debounce(fn, ms) {
        let t = null;
        return (...args) => {
          if (t) clearTimeout(t);
          t = setTimeout(() => fn(...args), ms);
        };
      }

      let currentGlobalAvg = NaN;
      let lastRequestKey = null;
      let lastMetricsByAreaKey = new Map();

      function roundCoord(x, decimals) {
        const p = Math.pow(10, decimals);
        return Math.round(x * p) / p;
      }

      function computeRequestKey() {
        const b = map.getBounds();
        const z = map.getZoom();
        const effectiveDepth = computeEffectiveMetricsDepth();
        // Keyed on a rounded bbox + zoom + metric to avoid unnecessary refetches on tiny pans.
        return [
          currentMetricId,
          String(effectiveDepth),
          roundCoord(b.getWest(), 4),
          roundCoord(b.getSouth(), 4),
          roundCoord(b.getEast(), 4),
          roundCoord(b.getNorth(), 4)
        ].join('|');
      }

      function computeEffectiveMetricsDepth() {
        const desired = depthForZoom(map.getZoom());
        // If tiles have been clamped (countries with missing deep levels), find the max depth actually present
        // in currently-rendered features and clamp the metrics request to that.
        const rendered = map.queryRenderedFeatures(undefined, { layers: ['boundaries-fill'] }) || [];
        let maxPresent = null;
        for (const f of rendered) {
          const d = computeDepthFromProps(f && f.properties);
          if (maxPresent == null || d > maxPresent) maxPresent = d;
          if (maxPresent === 5) break;
        }
        if (maxPresent == null) return desired;
        return Math.min(desired, maxPresent);
      }

      function applyMetricStatesToVisibleTiles() {
        // Apply whatever we have cached to currently rendered features.
        // This ensures newly loaded tiles get colored even if the last fetch was a 304.
        const rendered = map.queryRenderedFeatures(undefined, { layers: ['boundaries-fill'] }) || [];
        for (const f of rendered) {
          const id = f && f.id;
          const props = f && f.properties;
          const areaKey = props ? props.area_key : null;
          if (id == null || !areaKey) continue;

          const m = lastMetricsByAreaKey.get(areaKey);
          if (!m) {
            map.setFeatureState({ source: 'admin-tiles', sourceLayer: 'admin', id }, { band: null, avg: null });
            continue;
          }
          map.setFeatureState(
            { source: 'admin-tiles', sourceLayer: 'admin', id },
            { band: m.band ?? null, avg: m.avg ?? null }
          );
        }
      }

      async function refreshAreaMetrics() {
        try {
          const requestKey = computeRequestKey();
          if (requestKey === lastRequestKey) {
            applyMetricStatesToVisibleTiles();
            return;
          }
          lastRequestKey = requestKey;

          const b = map.getBounds();
          const url = new URL(apiBase + '/area-metrics-values');
          url.searchParams.set('minLon', String(b.getWest()));
          url.searchParams.set('minLat', String(b.getSouth()));
          url.searchParams.set('maxLon', String(b.getEast()));
          url.searchParams.set('maxLat', String(b.getNorth()));
          url.searchParams.set('metricId', currentMetricId);
          url.searchParams.set('depth', String(computeEffectiveMetricsDepth()));

          const res = await fetch(url.toString(), { headers: { 'Accept': 'application/json' } });
          if (res.status === 304) {
            applyMetricStatesToVisibleTiles();
            return;
          }
          if (!res.ok) return;

          const payload = await res.json();
          const items = (payload && Array.isArray(payload.items)) ? payload.items : [];

          lastMetricsByAreaKey = new Map();
          for (const it of items) {
            if (!it || !it.area_key) continue;
            lastMetricsByAreaKey.set(it.area_key, {
              band: it.band,
              avg: it.avg
            });
          }

          // Update legend subtitle with the computed global average if available.
          const subtitle = document.getElementById('legend-subtitle');
          const v = payload ? Number(payload.global_avg) : NaN;
          currentGlobalAvg = Number.isFinite(v) ? v : NaN;
          if (subtitle && Number.isFinite(currentGlobalAvg)) {
            subtitle.textContent = `Relative to bbox avg (${currentGlobalAvg.toFixed(0)})`;
          }

          applyMetricStatesToVisibleTiles();
        } catch (err) {
          // best-effort overlay
        }
      }

      const refreshAreaMetricsDebounced = debounce(refreshAreaMetrics, 250);
      map.on('moveend', refreshAreaMetricsDebounced);

      // Re-apply cached metrics as tiles stream in.
      const applyOnTilesDebounced = debounce(() => applyMetricStatesToVisibleTiles(), 100);
      map.on('sourcedata', (e) => {
        if (!e || e.sourceId !== 'admin-tiles') return;
        applyOnTilesDebounced();
      });
      refreshAreaMetrics();

      async function loadMetrics() {
        if (!metricSelect) return;
        metricSelect.disabled = true;
        metricSelect.innerHTML = '';
        const opt = document.createElement('option');
        opt.value = currentMetricId;
        opt.textContent = 'Loading…';
        metricSelect.appendChild(opt);

        try {
          const res = await fetch(apiBase + '/metrics', { headers: { 'Accept': 'application/json' } });
          if (!res.ok) throw new Error('metrics fetch failed');
          const metrics = await res.json();
          const items = Array.isArray(metrics) ? metrics : [];

          const saved = window.localStorage ? window.localStorage.getItem('mapster.metricId') : null;
          const defaultId = (saved && items.some(m => m && m.metricId === saved))
            ? saved
            : (items[0] && items[0].metricId ? items[0].metricId : currentMetricId);

          currentMetricId = defaultId;
          setLegendTitle();

          metricSelect.innerHTML = '';
          for (const m of items) {
            if (!m || !m.metricId) continue;
            const o = document.createElement('option');
            o.value = m.metricId;
            const label = m.description ? `${m.metricId} — ${m.description}` : m.metricId;
            o.textContent = label;
            metricSelect.appendChild(o);
          }
          metricSelect.value = currentMetricId;
          metricSelect.disabled = false;

          metricSelect.addEventListener('change', () => {
            currentMetricId = metricSelect.value;
            if (window.localStorage) window.localStorage.setItem('mapster.metricId', currentMetricId);
            setLegendTitle();
            refreshAreaMetrics();
          });

          refreshAreaMetrics();
        } catch (e) {
          metricSelect.disabled = false;
          metricSelect.innerHTML = '';
          const o = document.createElement('option');
          o.value = currentMetricId;
          o.textContent = currentMetricId;
          metricSelect.appendChild(o);
        }
      }

      loadMetrics();
    });
  </script>
</body>
</html>
