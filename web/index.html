<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mapster OSM + Boundaries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100vw; height: 100vh; }
    #legend {
      position: absolute;
      right: 12px;
      top: 12px;
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid #aaa;
      border-radius: 6px;
      padding: 10px;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      z-index: 11;
      max-width: 230px;
    }
    #legend .title { font-weight: 600; margin-bottom: 6px; }
    #legend .subtitle { color: #333; margin-bottom: 8px; }
    #legend .row { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    #legend .swatch { width: 14px; height: 14px; border-radius: 3px; border: 1px solid rgba(0,0,0,0.2); }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="legend">
    <div class="title">Land price bands</div>
    <div class="subtitle" id="legend-subtitle">Relative to bbox average</div>
    <div class="row"><span class="swatch" style="background:#00441b"></span><span>&le; 0.50× avg (very cheap)</span></div>
    <div class="row"><span class="swatch" style="background:#006d2c"></span><span>&le; 0.75× avg</span></div>
    <div class="row"><span class="swatch" style="background:#31a354"></span><span>&le; 0.90× avg</span></div>
    <div class="row"><span class="swatch" style="background:#74c476"></span><span>&le; 0.97× avg</span></div>
    <div class="row"><span class="swatch" style="background:#c7e9c0"></span><span>&le; 1.00× avg</span></div>
    <hr style="border:none;border-top:1px solid rgba(0,0,0,0.12);margin:8px 0;" />
    <div class="row"><span class="swatch" style="background:#fee5d9"></span><span>&gt; 1.00× avg</span></div>
    <div class="row"><span class="swatch" style="background:#fcae91"></span><span>&ge; 1.10× avg</span></div>
    <div class="row"><span class="swatch" style="background:#fb6a4a"></span><span>&ge; 1.25× avg</span></div>
    <div class="row"><span class="swatch" style="background:#de2d26"></span><span>&ge; 1.50× avg</span></div>
    <div class="row"><span class="swatch" style="background:#a50f15"></span><span>&ge; 2.00× avg (very expensive)</span></div>
  </div>
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
        // Tooltip element
        const tooltip = document.createElement('div');
        tooltip.style.position = 'absolute';
        tooltip.style.background = 'rgba(255,255,255,0.95)';
        tooltip.style.border = '1px solid #888';
        tooltip.style.borderRadius = '4px';
        tooltip.style.padding = '4px 8px';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.display = 'none';
        tooltip.style.zIndex = '10';
        document.body.appendChild(tooltip);
      console.log("Mapster script loaded");
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          osm: {
            type: 'raster',
            tiles: [
              'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            tileSize: 256,
            attribution: '© OpenStreetMap contributors'
          }
        },
        layers: [
          {
            id: 'osm',
            type: 'raster',
            source: 'osm',
            minzoom: 6,
            maxzoom: 11
          }
        ]
      },
      center: [13.4, 52.52], // Berlin
      zoom: 7,
      minZoom: 6,
      maxZoom: 11
    });

    // Vector tiles (MVT) served by the API.
    // These auto-load as you pan/zoom, and are generally much faster than shipping large GeoJSON blobs.

    function computeDepthFromProps(props) {
      // Depth is the count of populated name_1..name_5.
      // (name_0 is always the country name)
      let depth = 0;
      for (let i = 1; i <= 5; i++) {
        const v = props && props['name_' + i];
        if (typeof v === 'string' && v.trim() !== '') depth = i;
      }
      return depth;
    }

    map.on('load', () => {
      const METRIC_ID = 'price_eur_per_m2_land';

      // Local dev note:
      // - In Ingress-style setups, the browser can reach the API at same-origin `/api/...`.
      // - In docker-compose, the UI is on :8081 and the API is on :8080.
      // We keep this deterministic (no CORS-dependent probing).
      const apiBase = (() => {
        const sameOriginBase = window.location.origin + '/api';
        const hostBase = window.location.protocol + '//' + window.location.hostname + ':8080/api';
        if (window.location.port === '8081') return hostBase;
        return sameOriginBase;
      })();
      console.log('Using API base:', apiBase);

      map.addSource('admin-tiles', {
        type: 'vector',
        tiles: [apiBase + '/tiles/{z}/{x}/{y}.mvt'],
        minzoom: 0,
        maxzoom: 14
      });

      map.addSource('area-metrics', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      const bandToColor = {
        1: '#00441b',
        2: '#006d2c',
        3: '#31a354',
        4: '#74c476',
        5: '#c7e9c0',
        6: '#fee5d9',
        7: '#fcae91',
        8: '#fb6a4a',
        9: '#de2d26',
        10: '#a50f15'
      };

      const bandColorExpression = [
        'match',
        ['get', 'band'],
        1, bandToColor[1],
        2, bandToColor[2],
        3, bandToColor[3],
        4, bandToColor[4],
        5, bandToColor[5],
        6, bandToColor[6],
        7, bandToColor[7],
        8, bandToColor[8],
        9, bandToColor[9],
        10, bandToColor[10],
        'rgba(0,0,0,0)'
      ];

      // Transparent fill for hit-testing.
      map.addLayer({
        id: 'boundaries-fill',
        type: 'fill',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'fill-color': '#000000',
          'fill-opacity': 0
        }
      });

      // Hover highlight fill UNDER the lines so boundaries remain visible.
      map.addLayer({
        id: 'boundaries-highlight',
        type: 'fill',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'fill-color': '#00aaff',
          'fill-opacity': 0.18
        },
        filter: ['==', ['get', 'id'], '']
      });

      // Outline always on top.
      map.addLayer({
        id: 'boundaries-line',
        type: 'line',
        source: 'admin-tiles',
        'source-layer': 'admin',
        paint: {
          'line-color': '#ff0000',
          'line-width': 2
        }
      });

      // Metric shading (GeoJSON) underneath the boundary lines.
      map.addLayer({
        id: 'area-metrics-fill',
        type: 'fill',
        source: 'area-metrics',
        paint: {
          'fill-color': bandColorExpression,
          'fill-opacity': 0.38
        }
      }, 'boundaries-line');

      map.addLayer({
        id: 'area-metrics-highlight',
        type: 'fill',
        source: 'area-metrics',
        paint: {
          'fill-color': '#00aaff',
          'fill-opacity': 0.16
        },
        filter: ['==', ['get', 'area_key'], '']
      }, 'boundaries-line');

      // Single mousemove handler (no duplicates on refresh).
      map.on('mousemove', (e) => {
        const metricsFeatures = map.queryRenderedFeatures(e.point, { layers: ['area-metrics-fill'] });
        const features = map.queryRenderedFeatures(e.point, { layers: ['boundaries-fill'] });

        if (metricsFeatures && metricsFeatures.length > 0) {
          const f = metricsFeatures[0];
          const areaKey = f && f.properties ? f.properties.area_key : null;
          if (areaKey) {
            map.setFilter('area-metrics-highlight', ['==', ['get', 'area_key'], areaKey]);
          }
        } else {
          map.setFilter('area-metrics-highlight', ['==', ['get', 'area_key'], '']);
        }

        if (!features || features.length === 0) {
          map.setFilter('boundaries-highlight', ['==', ['get', 'id'], '']);
          tooltip.style.display = 'none';
          return;
        }

        // Prefer the most detailed feature if multiple overlap.
        let best = features[0];
        let bestDepth = computeDepthFromProps(best.properties);
        for (const f of features) {
          const d = computeDepthFromProps(f.properties);
          if (d > bestDepth) {
            best = f;
            bestDepth = d;
          }
        }

        const bestId = best && best.properties ? best.properties.id : null;
        if (bestId == null) {
          map.setFilter('boundaries-highlight', ['==', ['get', 'id'], '']);
          tooltip.style.display = 'none';
          return;
        }

        map.setFilter('boundaries-highlight', ['==', ['get', 'id'], bestId]);

        const names = [];
        for (let i = 0; i <= 5; i++) {
          const key = 'name_' + i;
          const v = best.properties && best.properties[key];
          if (typeof v === 'string' && v.trim() !== '') names.push(v);
        }
        if (names.length === 0 && best.properties && best.properties.name) {
          names.push(best.properties.name);
        }

        const metricLine = (() => {
          if (!metricsFeatures || metricsFeatures.length === 0) return null;
          const p = metricsFeatures[0].properties || {};
          const avg = p.avg;
          const globalAvg = p.global_avg;
          const ratio = p.ratio_to_avg;
          const band = p.band;
          if (avg == null || globalAvg == null || ratio == null || band == null) return null;
          const avgNum = Number(avg);
          const globalNum = Number(globalAvg);
          const ratioNum = Number(ratio);
          if (!Number.isFinite(avgNum) || !Number.isFinite(globalNum) || !Number.isFinite(ratioNum)) return null;
          return `avg: ${avgNum.toFixed(0)} (bbox avg: ${globalNum.toFixed(0)}, ${ratioNum.toFixed(2)}×, band ${band})`;
        })();

        tooltip.innerText = [
          ...(names.length > 0 ? [names.join('\n')] : ['Unknown']),
          ...(metricLine ? [metricLine] : [])
        ].join('\n');
        tooltip.style.display = 'block';
        tooltip.style.left = (e.originalEvent.clientX + 10) + 'px';
        tooltip.style.top = (e.originalEvent.clientY + 10) + 'px';
      });

      function debounce(fn, ms) {
        let t = null;
        return (...args) => {
          if (t) clearTimeout(t);
          t = setTimeout(() => fn(...args), ms);
        };
      }

      async function refreshAreaMetrics() {
        try {
          const b = map.getBounds();
          const url = new URL(apiBase + '/area-metrics');
          url.searchParams.set('minLon', String(b.getWest()));
          url.searchParams.set('minLat', String(b.getSouth()));
          url.searchParams.set('maxLon', String(b.getEast()));
          url.searchParams.set('maxLat', String(b.getNorth()));
          url.searchParams.set('metricId', METRIC_ID);
          url.searchParams.set('zoom', String(map.getZoom()));

          const res = await fetch(url.toString(), { headers: { 'Accept': 'application/json' } });
          if (!res.ok) return;

          const geojson = await res.json();
          const src = map.getSource('area-metrics');
          if (src && src.setData) src.setData(geojson);

          // Update legend subtitle with the computed global average if available.
          const subtitle = document.getElementById('legend-subtitle');
          const features = geojson && geojson.features ? geojson.features : [];
          const first = features.find(f => f && f.properties && f.properties.global_avg != null);
          if (subtitle && first && first.properties && first.properties.global_avg != null) {
            const v = Number(first.properties.global_avg);
            if (Number.isFinite(v)) subtitle.textContent = `Relative to bbox avg (${v.toFixed(0)})`;
          }
        } catch (err) {
          // best-effort overlay
        }
      }

      const refreshAreaMetricsDebounced = debounce(refreshAreaMetrics, 250);
      map.on('moveend', refreshAreaMetricsDebounced);
      refreshAreaMetrics();
    });
  </script>
</body>
</html>
