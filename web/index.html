<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mapster OSM + Boundaries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
        // Tooltip element
        const tooltip = document.createElement('div');
        tooltip.style.position = 'absolute';
        tooltip.style.background = 'rgba(255,255,255,0.95)';
        tooltip.style.border = '1px solid #888';
        tooltip.style.borderRadius = '4px';
        tooltip.style.padding = '4px 8px';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.display = 'none';
        tooltip.style.zIndex = '10';
        document.body.appendChild(tooltip);
      console.log("Mapster script loaded");
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          osm: {
            type: 'raster',
            tiles: [
              'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            tileSize: 256,
            attribution: '© OpenStreetMap contributors'
          }
        },
        layers: [
          {
            id: 'osm',
            type: 'raster',
            source: 'osm',
            minzoom: 6,
            maxzoom: 11
          }
        ]
      },
      center: [13.4, 52.52], // Berlin
      zoom: 7,
      minZoom: 6,
      maxZoom: 11
    });

    // Fetch overlays from backend API and add as a layer
    // Map OSM zoom (0-18) to 6 bands (0-5)
    function zoomToBand(zoom) {
      // 6 bands, each covering 1 zoom level from 6 to 11
      if (zoom < 7) return 0; // 6–7: name_0
      if (zoom < 8) return 1; // 7–8: name_1
      if (zoom < 9) return 2; // 8–9: name_2
      if (zoom < 10) return 3; // 9–10: name_3
      if (zoom < 11) return 4; // 10–11: name_4
      return 5; // 11+: name_5
    }

    let lastBand = null;
    let lastBounds = null;

    function emptyFeatureCollection() {
      return { type: 'FeatureCollection', features: [] };
    }

    function getBoundariesSource() {
      const src = map.getSource('boundaries');
      return src && typeof src.setData === 'function' ? src : null;
    }

    function computeDepthFromProps(props) {
      // Depth is the count of populated name_1..name_5.
      // (name_0 is always the country name)
      let depth = 0;
      for (let i = 1; i <= 5; i++) {
        const v = props && props['name_' + i];
        if (typeof v === 'string' && v.trim() !== '') depth = i;
      }
      return depth;
    }

    function boundsToArray(bounds) {
      return [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
    }

    function boundsChanged(a, b) {
      if (!a || !b) return true;
      for (let i = 0; i < 4; i++) {
        if (Math.abs(a[i] - b[i]) > 1e-6) return true;
      }
      return false;
    }

    function fetchAndDisplayOverlays(force = false) {
      const bounds = map.getBounds();
      const boundsArr = boundsToArray(bounds);
      const zoom = map.getZoom();
      const band = zoomToBand(zoom);
      const bboxChanged = boundsChanged(boundsArr, lastBounds);
      const bandChanged = band !== lastBand;
      if (force || bboxChanged || bandChanged) {
        lastBounds = boundsArr;
        lastBand = band;
        console.log(`Fetching overlays: zoom=${zoom}, band=${band}`);
        fetch(`http://localhost:8080/api/overlays?minLon=${boundsArr[0]}&minLat=${boundsArr[1]}&maxLon=${boundsArr[2]}&maxLat=${boundsArr[3]}&zoom=${zoom}`)
          .then(resp => resp.json())
          .then(data => {
            const featureCount = data && data.features ? data.features.length : 0;
            console.log(`Overlay fetch result: features=${featureCount}`);

            const src = getBoundariesSource();
            if (!src) {
              console.warn('Boundaries source not ready; skipping setData');
              return;
            }

            // Update data in-place; do not remove/re-add layers (prevents event-handler buildup
            // and preserves layer order).
            src.setData(data || emptyFeatureCollection());

            // Clear any existing hover highlight on data refresh.
            if (map.getLayer('boundaries-highlight')) {
              map.setFilter('boundaries-highlight', ['==', ['get', 'id'], '']);
            }
          });
      }
    }

    map.on('load', () => {
      // Create a stable source + layer stack once, then update via setData().
      map.addSource('boundaries', {
        type: 'geojson',
        data: emptyFeatureCollection()
      });

      // Transparent fill for hit-testing.
      map.addLayer({
        id: 'boundaries-fill',
        type: 'fill',
        source: 'boundaries',
        paint: {
          'fill-color': '#000000',
          'fill-opacity': 0
        }
      });

      // Hover highlight fill UNDER the lines so boundaries remain visible.
      map.addLayer({
        id: 'boundaries-highlight',
        type: 'fill',
        source: 'boundaries',
        paint: {
          'fill-color': '#00aaff',
          'fill-opacity': 0.18
        },
        filter: ['==', ['get', 'id'], '']
      });

      // Outline always on top.
      map.addLayer({
        id: 'boundaries-line',
        type: 'line',
        source: 'boundaries',
        paint: {
          'line-color': '#ff0000',
          'line-width': 2
        }
      });

      // Single mousemove handler (no duplicates on refresh).
      map.on('mousemove', (e) => {
        const features = map.queryRenderedFeatures(e.point, { layers: ['boundaries-fill'] });
        if (!features || features.length === 0) {
          map.setFilter('boundaries-highlight', ['==', ['get', 'id'], '']);
          tooltip.style.display = 'none';
          return;
        }

        // Prefer the most detailed feature if multiple overlap.
        let best = features[0];
        let bestDepth = computeDepthFromProps(best.properties);
        for (const f of features) {
          const d = computeDepthFromProps(f.properties);
          if (d > bestDepth) {
            best = f;
            bestDepth = d;
          }
        }

        const bestId = best && best.properties ? best.properties.id : null;
        if (bestId == null) {
          map.setFilter('boundaries-highlight', ['==', ['get', 'id'], '']);
          tooltip.style.display = 'none';
          return;
        }

        map.setFilter('boundaries-highlight', ['==', ['get', 'id'], bestId]);

        const names = [];
        for (let i = 0; i <= 5; i++) {
          const key = 'name_' + i;
          const v = best.properties && best.properties[key];
          if (typeof v === 'string' && v.trim() !== '') names.push(v);
        }
        if (names.length === 0 && best.properties && best.properties.name) {
          names.push(best.properties.name);
        }

        tooltip.innerText = names.length > 0 ? names.join('\n') : 'Unknown';
        tooltip.style.display = 'block';
        tooltip.style.left = (e.originalEvent.clientX + 10) + 'px';
        tooltip.style.top = (e.originalEvent.clientY + 10) + 'px';
      });

      fetchAndDisplayOverlays(true);
    });
    map.on('moveend', () => fetchAndDisplayOverlays());
    map.on('zoomend', () => fetchAndDisplayOverlays());
  </script>
</body>
</html>
