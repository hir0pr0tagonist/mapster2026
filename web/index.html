<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mapster OSM + Boundaries</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
        // Tooltip element
        const tooltip = document.createElement('div');
        tooltip.style.position = 'absolute';
        tooltip.style.background = 'rgba(255,255,255,0.95)';
        tooltip.style.border = '1px solid #888';
        tooltip.style.borderRadius = '4px';
        tooltip.style.padding = '4px 8px';
        tooltip.style.pointerEvents = 'none';
        tooltip.style.display = 'none';
        tooltip.style.zIndex = '10';
        document.body.appendChild(tooltip);
      console.log("Mapster script loaded");
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          osm: {
            type: 'raster',
            tiles: [
              'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            tileSize: 256,
            attribution: '© OpenStreetMap contributors'
          }
        },
        layers: [
          {
            id: 'osm',
            type: 'raster',
            source: 'osm',
            minzoom: 6,
            maxzoom: 11
          }
        ]
      },
      center: [13.4, 52.52], // Berlin
      zoom: 7,
      minZoom: 6,
      maxZoom: 11
    });

    // Fetch overlays from backend API and add as a layer
    // Map OSM zoom (0-18) to 6 bands (0-5)
    function zoomToBand(zoom) {
      // 6 bands, each covering 1 zoom level from 6 to 11
      if (zoom < 7) return 0; // 6–7: name_0
      if (zoom < 8) return 1; // 7–8: name_1
      if (zoom < 9) return 2; // 8–9: name_2
      if (zoom < 10) return 3; // 9–10: name_3
      if (zoom < 11) return 4; // 10–11: name_4
      return 5; // 11+: name_5
    }

    let lastBand = null;
    let lastBounds = null;

    function boundsToArray(bounds) {
      return [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
    }

    function boundsChanged(a, b) {
      if (!a || !b) return true;
      for (let i = 0; i < 4; i++) {
        if (Math.abs(a[i] - b[i]) > 1e-6) return true;
      }
      return false;
    }

    function fetchAndDisplayOverlays(force = false) {
      const bounds = map.getBounds();
      const boundsArr = boundsToArray(bounds);
      const zoom = map.getZoom();
      const band = zoomToBand(zoom);
      const bboxChanged = boundsChanged(boundsArr, lastBounds);
      const bandChanged = band !== lastBand;
      if (force || bboxChanged || bandChanged) {
        lastBounds = boundsArr;
        lastBand = band;
        console.log(`Fetching overlays: zoom=${zoom}, band=${band}`);
        fetch(`http://localhost:8080/api/overlays?minLon=${boundsArr[0]}&minLat=${boundsArr[1]}&maxLon=${boundsArr[2]}&maxLat=${boundsArr[3]}&band=${band}`)
          .then(resp => resp.json())
          .then(data => {
            const featureCount = data && data.features ? data.features.length : 0;
            console.log(`Overlay fetch result: features=${featureCount}`);
            // Remove previous boundaries layer and source if they exist
            if (map.getLayer('boundaries-line')) {
              map.removeLayer('boundaries-line');
            }
            if (map.getLayer('boundaries-fill')) {
              map.removeLayer('boundaries-fill');
            }
            if (map.getLayer('boundaries-highlight')) {
              map.removeLayer('boundaries-highlight');
            }
            if (map.getSource('boundaries')) {
              map.removeSource('boundaries');
            }
            // Add new boundaries source and layers
            map.addSource('boundaries', {
              type: 'geojson',
              data: data
            });
            // Add transparent fill layer for mouse detection
            map.addLayer({
              id: 'boundaries-fill',
              type: 'fill',
              source: 'boundaries',
              paint: {
                'fill-color': '#000000',
                'fill-opacity': 0
              }
            });
            map.addLayer({
              id: 'boundaries-line',
              type: 'line',
              source: 'boundaries',
              paint: {
                'line-color': '#ff0000',
                'line-width': 2
              }
            });
            map.addLayer({
              id: 'boundaries-highlight',
              type: 'fill',
              source: 'boundaries',
              paint: {
                'fill-color': '#00aaff',
                'fill-opacity': 0.3
              },
              filter: ['==', 'id', ''] // No highlight by default
            });
            // Mousemove detection for fill highlight
            map.on('mousemove', (e) => {
              const features = map.queryRenderedFeatures(e.point, { layers: ['boundaries-fill'] });
              if (features && features.length > 0) {
                const feature = features[0];
                map.setFilter('boundaries-highlight', ['==', 'id', feature.properties.id]);
                // Show tooltip with best available name
                // Assemble hierarchical names for tooltip
                const names = [];
                for (let i = 0; i <= 5; i++) {
                  const key = 'name_' + i;
                  if (feature.properties[key] && feature.properties[key].trim() !== '') {
                    names.push(feature.properties[key]);
                  }
                }
                // Fallback: if no name_x, try 'name'
                if (names.length === 0 && feature.properties.name) {
                  names.push(feature.properties.name);
                }
                tooltip.innerText = names.length > 0 ? names.join('\n') : 'Unknown';
                tooltip.style.display = 'block';
                tooltip.style.left = (e.originalEvent.clientX + 10) + 'px';
                tooltip.style.top = (e.originalEvent.clientY + 10) + 'px';
              } else {
                map.setFilter('boundaries-highlight', ['==', 'id', '']);
                tooltip.style.display = 'none';
              }
            });
          });
      }
    }

    map.on('load', () => fetchAndDisplayOverlays(true));
    map.on('moveend', () => fetchAndDisplayOverlays());
    map.on('zoomend', () => fetchAndDisplayOverlays());
  </script>
</body>
</html>
